## Problema

27 - Considera o seguinte código:

```cs
public class Power
{
    public string Description { get; set; }
    public int Range { get; set; }
}

public class PlayerClass
{
    private int health;
    private int shield;
    private List<Power> powers;

    public PlayerClass(int health, int shield)
    {
        this.health = health;
        this.shield = shield;
        powers = new List<Power>();
    }

    public void AddPower(Power p)
    {
        powers.Add(p);
    }
}

public struct PlayerStruct
{
    private int health;
    private int shield;
    private List<Power> powers;

    public PlayerStruct(int health, int shield)
    {
        this.health = health;
        this.shield = shield;
        powers = new List<Power>();
    }

    public void AddPower(Power p)
    {
        powers.Add(p);
    }
}
```

Pretende-se que os tipos `PlayerClass` e `PlayerStruct` implementem a interface
[`ICloneable`](https://docs.microsoft.com/dotnet/api/system.icloneable), de
modo a que uma chamada ao respetivo método
[`IClone()`](https://docs.microsoft.com/dotnet/api/system.icloneable.clone)
devolva uma cópia profunda da instância em questão. Uma cópia profunda consiste
numa nova instância cujos campos têm o mesmo valor do objeto original. Se algum
dos campos for um tipo de referência, a instância associada deve também ser
clonada da mesma forma, e por ai fora. Reescreve o código dos tipos
`PlayerClass` e `PlayerStruct` de modo a que implementem
[`ICloneable`](https://docs.microsoft.com/dotnet/api/system.icloneable) segundo
estas especificações.

## Soluções

### Solução 1

```cs
public class Power
{
    public string Description { get; set; }
    public int Range { get; set; }
}

public class PlayerClass : ICloneable
{
    private int health;
    private int shield;
    private List<Power> powers;

    public PlayerClass(int health, int shield)
    {
        this.health = health;
        this.shield = shield;
        powers = new List<Power>();
    }

    public void AddPower(Power p)
    {
        powers.Add(p);
    }

    public object Clone()
    {
        PlayerClass pClone = new PlayerClass(health, shield);
        pClone.powers = new List<Power>(powers.Count);

        foreach(Power p in powers)
        {
            pClone.powers.Add(p);
        }

        return pClone;
    }
}

public struct PlayerStruct : ICloneable
{
    private int health;
    private int shield;
    private List<Power> powers;

    public PlayerStruct(int health, int shield)
    {
        this.health = health;
        this.shield = shield;
        powers = new List<Power>();
    }

    public void AddPower(Power p)
    {
        powers.Add(p);
    }

    public object Clone()
    {
        PlayerStruct pClone = this;

        pClone.powers = new List<Power>(powers.Count);

        foreach (Power p in powers)
        {
            pClone.powers.Add(p);
        }

        return pClone;
    }
}
```

*Por [Diogo Martins](https://github.com/diogo-martins99)*