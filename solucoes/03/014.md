## Problema

14 - Considera o seguinte código:

```cs
class Program
{
    static void Main(string[] args)
    {
        int[] arrayOfInts = new int[] { 1, 2, 3, 4 };
        foreach (int i in arrayOfInts)
        {
            Console.WriteLine(i);
        }
    }
}
```

1.  Converte o código apresentado para que faça uso explícito do
    [enumerador](https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerator-1)
    devolvido pelo _array_.
2.  Qual é ou quais são as vantagens do uso de `foreach` sobre o uso explícito
    de enumeradores?
3.  Qual é a interface que a classe
    [`array`](https://docs.microsoft.com/dotnet/api/system.array) implementa
    que a obriga a ter um método para devolver um enumerador? Esta
    implementação é direta ou através de outras interfaces intermédias? Se se
    verificar este último caso, indica essa hierarquia de interfaces.
4.  Qual é o _design pattern_ que propõe esta forma de aceder sequencialmente
    aos elementos de um objeto agregado/coleção, independentemente da forma
    como o mesmo foi implementado.

## Soluções

### Solução 1

1.
```cs
class Program
{
    static void Main(string[] args)
    {
        int[] arrayOfInts = new int[] { 1, 2, 3, 4 };
        while (arrayOfInts.GetEnumerator().MoveNext())
        {
            int i = (int) arrayOfInts.GetEnumerator().Current;
            Console.WriteLine(i);
        }
    }
}
```

2. O `foreach` esconde a complexidade dos enumeradores pelo que é preferível usá-lo ao invés de manipular diretamente os `enumerators`.

3. A interaface que a classe implementa é um _IEnumerable_ e trata-se de uma implementação através de outras interfaces intermédias, nomeadamente _IList_ que implementa _ICollection_ que por sua vez implementa _IEnumerable_.

4. O design pattern é o _Iterator Pattern_.

*Por [Diogo Martins](https://github.com/diogo-martins99)*